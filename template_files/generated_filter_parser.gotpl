// Code generated by github.com/web-ridge/gqlgen-sqlboiler, DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	"strings"

	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"

	"code.gleez.io/vdesk/util/boilergql"
	
	{{ range $import := .Imports }}
		{{ $import.Alias }} "{{ $import.ImportPath }}"
	{{ end }}
)

{{ range $model := .Models }}

	{{- if and .IsWhere .HasBoilerModel -}}
		func {{ .Name }}ParserToMods(m *{{ $.Frontend.PackageName }}.{{ .Name }}) []qm.QueryMod {
			if m == nil {
				return nil
			}
			
			var queryMods []qm.QueryMod
		
			if m.Query != nil {
				qs, _ := {{ .BoilerModel.Name }}QueryToMods(*m.Query)
				queryMods = append(queryMods, qs...)
			}
		
			return queryMods
		}
		
		func {{ .BoilerModel.Name }}QueryToMods(query string) ([]qm.QueryMod, error) {
			if query == "" {
				return nil, nil
			}

			tokens, err := tokenize(query)
			if err != nil {
				return nil, err
			}
			
			var queryMods []qm.QueryMod
		
			sortingDone := false
			
			for _, t := range tokens {
				switch t.kind {
					case tokenKindKV:
					switch t.qualifier {
						{{- $model := . -}}
						{{- range $field := .Fields }}
							{{-  if $field.BoilerField.InTable }}
							{{- if eq $field.BoilerField.Name "CreatedAt" }}
							case "created":
								queryMods = append(queryMods, qmhelper.Where({{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}, qmhelper.EQ, t.value))
							{{- else if eq $field.BoilerField.Name "UpdatedAt" }}
							case "updated":
								queryMods = append(queryMods, qmhelper.Where({{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}, qmhelper.EQ, t.value))
							{{- else }}
							case "{{ $field.BoilerField.Name | camel }}":
								queryMods = append(queryMods, qmhelper.Where({{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}, qmhelper.EQ, t.value))
							{{- end }}
							{{- end -}}
						{{- end }}

						case "no":
							switch t.value {
						{{- range $field := .Fields }}
							{{-  if $field.BoilerField.InTable }}
							case "{{ $field.BoilerField.Name | camel }}":
								queryMods = append(queryMods, qmhelper.WhereIsNull({{ $.Backend.PackageName }}.{{ $model.BoilerModel.Name }}Columns.{{ $field.BoilerField.Name }}))
							{{- end -}}
						{{- end }}
							default:
								return nil, fmt.Errorf("unknown \"no\" query filter \"%s\"", t.value)
							}
				
						case "sort":
							if sortingDone {
								return nil, fmt.Errorf("multiple sorting not supported")
							}
			
							qm, err := {{ .BoilerModel.Name | lcFirst}}ParseSorting(t.value)
							if err != nil {
								return nil, err
							}
			
							queryMods = append(queryMods, qm...)
							sortingDone = true
				
						default:
							return nil, fmt.Errorf("unknown qualifier \"%s\"", t.qualifier)
					}
				}
			}
	
			return queryMods, nil
		}
		
		func {{ .BoilerModel.Name | lcFirst}}ParseSorting(value string) ([]qm.QueryMod, error) {
			var a []*models.{{ .BoilerModel.Name}}Order
		
			switch value {
			// default ASC
			case "id-desc":
				a = []*models.{{ .BoilerModel.Name}}Order{ {Field: models.{{ .BoilerModel.Name}}SortID, Direction: boilergql.SortDirectionDesc} }
			case "id", "id-asc":
				a = []*models.{{ .BoilerModel.Name}}Order{ {Field: models.{{ .BoilerModel.Name}}SortID, Direction: boilergql.SortDirectionAsc} }
		
			// default DESC
			case "created", "created-desc":
				a = []*models.{{ .BoilerModel.Name}}Order{ {Field: models.{{ .BoilerModel.Name}}SortCreatedAt, Direction: boilergql.SortDirectionDesc} }
			case "created-asc":
				a = []*models.{{ .BoilerModel.Name}}Order{ {Field: models.{{ .BoilerModel.Name}}SortCreatedAt, Direction: boilergql.SortDirectionAsc} }
		
			// default DESC
			case "updated", "updated-desc":
				a = []*models.{{ .BoilerModel.Name}}Order{ {Field: models.{{ .BoilerModel.Name}}SortUpdatedAt, Direction: boilergql.SortDirectionDesc} }
			case "updated-asc":
				a = []*models.{{ .BoilerModel.Name}}Order{ {Field: models.{{ .BoilerModel.Name}}SortUpdatedAt, Direction: boilergql.SortDirectionAsc} }
		
			default:
				return nil, fmt.Errorf("unknown sorting %s", value)
			}
		
			defaultDirection := {{ .BoilerModel.Name}}SortDirection(a)
			return {{ .BoilerModel.Name}}SortMods(a, false, defaultDirection), nil
		}
	{{ end }}

{{ end }}
